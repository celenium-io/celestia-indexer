// SPDX-FileCopyrightText: 2025 Bb Strategy Pte. Ltd. <celenium@baking-bad.org>
// SPDX-License-Identifier: MIT

// Code generated by MockGen. DO NOT EDIT.
// Source: upgrade.go
//
// Generated by this command:
//
//	mockgen -source=upgrade.go -destination=mock/upgrade.go -package=mock -typed
//

// Package mock is a generated GoMock package.
package mock

import (
	context "context"
	reflect "reflect"

	storage "github.com/celenium-io/celestia-indexer/internal/storage"
	gomock "go.uber.org/mock/gomock"
)

// MockIUpgrade is a mock of IUpgrade interface.
type MockIUpgrade struct {
	ctrl     *gomock.Controller
	recorder *MockIUpgradeMockRecorder
}

// MockIUpgradeMockRecorder is the mock recorder for MockIUpgrade.
type MockIUpgradeMockRecorder struct {
	mock *MockIUpgrade
}

// NewMockIUpgrade creates a new mock instance.
func NewMockIUpgrade(ctrl *gomock.Controller) *MockIUpgrade {
	mock := &MockIUpgrade{ctrl: ctrl}
	mock.recorder = &MockIUpgradeMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockIUpgrade) EXPECT() *MockIUpgradeMockRecorder {
	return m.recorder
}

// ByVersion mocks base method.
func (m *MockIUpgrade) ByVersion(ctx context.Context, version uint64) (storage.Upgrade, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "ByVersion", ctx, version)
	ret0, _ := ret[0].(storage.Upgrade)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// ByVersion indicates an expected call of ByVersion.
func (mr *MockIUpgradeMockRecorder) ByVersion(ctx, version any) *MockIUpgradeByVersionCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "ByVersion", reflect.TypeOf((*MockIUpgrade)(nil).ByVersion), ctx, version)
	return &MockIUpgradeByVersionCall{Call: call}
}

// MockIUpgradeByVersionCall wrap *gomock.Call
type MockIUpgradeByVersionCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIUpgradeByVersionCall) Return(arg0 storage.Upgrade, arg1 error) *MockIUpgradeByVersionCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIUpgradeByVersionCall) Do(f func(context.Context, uint64) (storage.Upgrade, error)) *MockIUpgradeByVersionCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIUpgradeByVersionCall) DoAndReturn(f func(context.Context, uint64) (storage.Upgrade, error)) *MockIUpgradeByVersionCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}

// List mocks base method.
func (m *MockIUpgrade) List(ctx context.Context, flts storage.ListUpgradesFilter) ([]storage.Upgrade, error) {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "List", ctx, flts)
	ret0, _ := ret[0].([]storage.Upgrade)
	ret1, _ := ret[1].(error)
	return ret0, ret1
}

// List indicates an expected call of List.
func (mr *MockIUpgradeMockRecorder) List(ctx, flts any) *MockIUpgradeListCall {
	mr.mock.ctrl.T.Helper()
	call := mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "List", reflect.TypeOf((*MockIUpgrade)(nil).List), ctx, flts)
	return &MockIUpgradeListCall{Call: call}
}

// MockIUpgradeListCall wrap *gomock.Call
type MockIUpgradeListCall struct {
	*gomock.Call
}

// Return rewrite *gomock.Call.Return
func (c *MockIUpgradeListCall) Return(arg0 []storage.Upgrade, arg1 error) *MockIUpgradeListCall {
	c.Call = c.Call.Return(arg0, arg1)
	return c
}

// Do rewrite *gomock.Call.Do
func (c *MockIUpgradeListCall) Do(f func(context.Context, storage.ListUpgradesFilter) ([]storage.Upgrade, error)) *MockIUpgradeListCall {
	c.Call = c.Call.Do(f)
	return c
}

// DoAndReturn rewrite *gomock.Call.DoAndReturn
func (c *MockIUpgradeListCall) DoAndReturn(f func(context.Context, storage.ListUpgradesFilter) ([]storage.Upgrade, error)) *MockIUpgradeListCall {
	c.Call = c.Call.DoAndReturn(f)
	return c
}
