// SPDX-FileCopyrightText: 2024 PK Lab AG <contact@pklab.io>
// SPDX-License-Identifier: MIT

// Code generated by go-enum DO NOT EDIT.
// Version: 0.5.7
// Revision: bf63e108589bbd2327b13ec2c5da532aad234029
// Build Date: 2023-07-25T23:27:55Z
// Built By: goreleaser

package types

import (
	"database/sql/driver"
	"errors"
	"fmt"
	"strings"
)

const (
	// ProposalStatusInactive is a ProposalStatus of type inactive.
	ProposalStatusInactive ProposalStatus = "inactive"
	// ProposalStatusActive is a ProposalStatus of type active.
	ProposalStatusActive ProposalStatus = "active"
	// ProposalStatusRemoved is a ProposalStatus of type removed.
	ProposalStatusRemoved ProposalStatus = "removed"
	// ProposalStatusApplied is a ProposalStatus of type applied.
	ProposalStatusApplied ProposalStatus = "applied"
	// ProposalStatusRejected is a ProposalStatus of type rejected.
	ProposalStatusRejected ProposalStatus = "rejected"
)

var ErrInvalidProposalStatus = fmt.Errorf("not a valid ProposalStatus, try [%s]", strings.Join(_ProposalStatusNames, ", "))

var _ProposalStatusNames = []string{
	string(ProposalStatusInactive),
	string(ProposalStatusActive),
	string(ProposalStatusRemoved),
	string(ProposalStatusApplied),
	string(ProposalStatusRejected),
}

// ProposalStatusNames returns a list of possible string values of ProposalStatus.
func ProposalStatusNames() []string {
	tmp := make([]string, len(_ProposalStatusNames))
	copy(tmp, _ProposalStatusNames)
	return tmp
}

// ProposalStatusValues returns a list of the values for ProposalStatus
func ProposalStatusValues() []ProposalStatus {
	return []ProposalStatus{
		ProposalStatusInactive,
		ProposalStatusActive,
		ProposalStatusRemoved,
		ProposalStatusApplied,
		ProposalStatusRejected,
	}
}

// String implements the Stringer interface.
func (x ProposalStatus) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ProposalStatus) IsValid() bool {
	_, err := ParseProposalStatus(string(x))
	return err == nil
}

var _ProposalStatusValue = map[string]ProposalStatus{
	"inactive": ProposalStatusInactive,
	"active":   ProposalStatusActive,
	"removed":  ProposalStatusRemoved,
	"applied":  ProposalStatusApplied,
	"rejected": ProposalStatusRejected,
}

// ParseProposalStatus attempts to convert a string to a ProposalStatus.
func ParseProposalStatus(name string) (ProposalStatus, error) {
	if x, ok := _ProposalStatusValue[name]; ok {
		return x, nil
	}
	return ProposalStatus(""), fmt.Errorf("%s is %w", name, ErrInvalidProposalStatus)
}

// MarshalText implements the text marshaller method.
func (x ProposalStatus) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ProposalStatus) UnmarshalText(text []byte) error {
	tmp, err := ParseProposalStatus(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errProposalStatusNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ProposalStatus) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ProposalStatus("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseProposalStatus(v)
	case []byte:
		*x, err = ParseProposalStatus(string(v))
	case ProposalStatus:
		*x = v
	case *ProposalStatus:
		if v == nil {
			return errProposalStatusNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errProposalStatusNilPtr
		}
		*x, err = ParseProposalStatus(*v)
	default:
		return errors.New("invalid type for ProposalStatus")
	}

	return
}

// Value implements the driver Valuer interface.
func (x ProposalStatus) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// ProposalTypeParamChanged is a ProposalType of type param_changed.
	ProposalTypeParamChanged ProposalType = "param_changed"
	// ProposalTypeText is a ProposalType of type text.
	ProposalTypeText ProposalType = "text"
	// ProposalTypeClientUpdate is a ProposalType of type client_update.
	ProposalTypeClientUpdate ProposalType = "client_update"
	// ProposalTypeCommunityPoolSpend is a ProposalType of type community_pool_spend.
	ProposalTypeCommunityPoolSpend ProposalType = "community_pool_spend"
)

var ErrInvalidProposalType = fmt.Errorf("not a valid ProposalType, try [%s]", strings.Join(_ProposalTypeNames, ", "))

var _ProposalTypeNames = []string{
	string(ProposalTypeParamChanged),
	string(ProposalTypeText),
	string(ProposalTypeClientUpdate),
	string(ProposalTypeCommunityPoolSpend),
}

// ProposalTypeNames returns a list of possible string values of ProposalType.
func ProposalTypeNames() []string {
	tmp := make([]string, len(_ProposalTypeNames))
	copy(tmp, _ProposalTypeNames)
	return tmp
}

// ProposalTypeValues returns a list of the values for ProposalType
func ProposalTypeValues() []ProposalType {
	return []ProposalType{
		ProposalTypeParamChanged,
		ProposalTypeText,
		ProposalTypeClientUpdate,
		ProposalTypeCommunityPoolSpend,
	}
}

// String implements the Stringer interface.
func (x ProposalType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x ProposalType) IsValid() bool {
	_, err := ParseProposalType(string(x))
	return err == nil
}

var _ProposalTypeValue = map[string]ProposalType{
	"param_changed":        ProposalTypeParamChanged,
	"text":                 ProposalTypeText,
	"client_update":        ProposalTypeClientUpdate,
	"community_pool_spend": ProposalTypeCommunityPoolSpend,
}

// ParseProposalType attempts to convert a string to a ProposalType.
func ParseProposalType(name string) (ProposalType, error) {
	if x, ok := _ProposalTypeValue[name]; ok {
		return x, nil
	}
	return ProposalType(""), fmt.Errorf("%s is %w", name, ErrInvalidProposalType)
}

// MarshalText implements the text marshaller method.
func (x ProposalType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *ProposalType) UnmarshalText(text []byte) error {
	tmp, err := ParseProposalType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errProposalTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *ProposalType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = ProposalType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseProposalType(v)
	case []byte:
		*x, err = ParseProposalType(string(v))
	case ProposalType:
		*x = v
	case *ProposalType:
		if v == nil {
			return errProposalTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errProposalTypeNilPtr
		}
		*x, err = ParseProposalType(*v)
	default:
		return errors.New("invalid type for ProposalType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x ProposalType) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// VoteOptionYes is a VoteOption of type yes.
	VoteOptionYes VoteOption = "yes"
	// VoteOptionNo is a VoteOption of type no.
	VoteOptionNo VoteOption = "no"
	// VoteOptionNoWithVeto is a VoteOption of type no_with_veto.
	VoteOptionNoWithVeto VoteOption = "no_with_veto"
	// VoteOptionAbstain is a VoteOption of type abstain.
	VoteOptionAbstain VoteOption = "abstain"
)

var ErrInvalidVoteOption = fmt.Errorf("not a valid VoteOption, try [%s]", strings.Join(_VoteOptionNames, ", "))

var _VoteOptionNames = []string{
	string(VoteOptionYes),
	string(VoteOptionNo),
	string(VoteOptionNoWithVeto),
	string(VoteOptionAbstain),
}

// VoteOptionNames returns a list of possible string values of VoteOption.
func VoteOptionNames() []string {
	tmp := make([]string, len(_VoteOptionNames))
	copy(tmp, _VoteOptionNames)
	return tmp
}

// VoteOptionValues returns a list of the values for VoteOption
func VoteOptionValues() []VoteOption {
	return []VoteOption{
		VoteOptionYes,
		VoteOptionNo,
		VoteOptionNoWithVeto,
		VoteOptionAbstain,
	}
}

// String implements the Stringer interface.
func (x VoteOption) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x VoteOption) IsValid() bool {
	_, err := ParseVoteOption(string(x))
	return err == nil
}

var _VoteOptionValue = map[string]VoteOption{
	"yes":          VoteOptionYes,
	"no":           VoteOptionNo,
	"no_with_veto": VoteOptionNoWithVeto,
	"abstain":      VoteOptionAbstain,
}

// ParseVoteOption attempts to convert a string to a VoteOption.
func ParseVoteOption(name string) (VoteOption, error) {
	if x, ok := _VoteOptionValue[name]; ok {
		return x, nil
	}
	return VoteOption(""), fmt.Errorf("%s is %w", name, ErrInvalidVoteOption)
}

// MarshalText implements the text marshaller method.
func (x VoteOption) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *VoteOption) UnmarshalText(text []byte) error {
	tmp, err := ParseVoteOption(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errVoteOptionNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *VoteOption) Scan(value interface{}) (err error) {
	if value == nil {
		*x = VoteOption("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseVoteOption(v)
	case []byte:
		*x, err = ParseVoteOption(string(v))
	case VoteOption:
		*x = v
	case *VoteOption:
		if v == nil {
			return errVoteOptionNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errVoteOptionNilPtr
		}
		*x, err = ParseVoteOption(*v)
	default:
		return errors.New("invalid type for VoteOption")
	}

	return
}

// Value implements the driver Valuer interface.
func (x VoteOption) Value() (driver.Value, error) {
	return x.String(), nil
}

const (
	// VoterTypeAddress is a VoterType of type address.
	VoterTypeAddress VoterType = "address"
	// VoterTypeValidator is a VoterType of type validator.
	VoterTypeValidator VoterType = "validator"
)

var ErrInvalidVoterType = fmt.Errorf("not a valid VoterType, try [%s]", strings.Join(_VoterTypeNames, ", "))

var _VoterTypeNames = []string{
	string(VoterTypeAddress),
	string(VoterTypeValidator),
}

// VoterTypeNames returns a list of possible string values of VoterType.
func VoterTypeNames() []string {
	tmp := make([]string, len(_VoterTypeNames))
	copy(tmp, _VoterTypeNames)
	return tmp
}

// VoterTypeValues returns a list of the values for VoterType
func VoterTypeValues() []VoterType {
	return []VoterType{
		VoterTypeAddress,
		VoterTypeValidator,
	}
}

// String implements the Stringer interface.
func (x VoterType) String() string {
	return string(x)
}

// IsValid provides a quick way to determine if the typed value is
// part of the allowed enumerated values
func (x VoterType) IsValid() bool {
	_, err := ParseVoterType(string(x))
	return err == nil
}

var _VoterTypeValue = map[string]VoterType{
	"address":   VoterTypeAddress,
	"validator": VoterTypeValidator,
}

// ParseVoterType attempts to convert a string to a VoterType.
func ParseVoterType(name string) (VoterType, error) {
	if x, ok := _VoterTypeValue[name]; ok {
		return x, nil
	}
	return VoterType(""), fmt.Errorf("%s is %w", name, ErrInvalidVoterType)
}

// MarshalText implements the text marshaller method.
func (x VoterType) MarshalText() ([]byte, error) {
	return []byte(string(x)), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *VoterType) UnmarshalText(text []byte) error {
	tmp, err := ParseVoterType(string(text))
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

var errVoterTypeNilPtr = errors.New("value pointer is nil") // one per type for package clashes

// Scan implements the Scanner interface.
func (x *VoterType) Scan(value interface{}) (err error) {
	if value == nil {
		*x = VoterType("")
		return
	}

	// A wider range of scannable types.
	// driver.Value values at the top of the list for expediency
	switch v := value.(type) {
	case string:
		*x, err = ParseVoterType(v)
	case []byte:
		*x, err = ParseVoterType(string(v))
	case VoterType:
		*x = v
	case *VoterType:
		if v == nil {
			return errVoterTypeNilPtr
		}
		*x = *v
	case *string:
		if v == nil {
			return errVoterTypeNilPtr
		}
		*x, err = ParseVoterType(*v)
	default:
		return errors.New("invalid type for VoterType")
	}

	return
}

// Value implements the driver Valuer interface.
func (x VoterType) Value() (driver.Value, error) {
	return x.String(), nil
}
